// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64 || wasm

package bpf

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadDeny returns the embedded CollectionSpec for deny.
func loadDeny() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_DenyBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load deny: %w", err)
	}

	return spec, err
}

// loadDenyObjects loads deny and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*denyObjects
//	*denyPrograms
//	*denyMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadDenyObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadDeny()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// denySpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type denySpecs struct {
	denyProgramSpecs
	denyMapSpecs
	denyVariableSpecs
}

// denyProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type denyProgramSpecs struct {
	DenyFileOpen *ebpf.ProgramSpec `ebpf:"deny_file_open"`
}

// denyMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type denyMapSpecs struct {
	AllowedFilenames *ebpf.MapSpec `ebpf:"allowed_filenames"`
	DeniedFilenames  *ebpf.MapSpec `ebpf:"denied_filenames"`
	DeniedInodes     *ebpf.MapSpec `ebpf:"denied_inodes"`
	Events           *ebpf.MapSpec `ebpf:"events"`
	TargetPids       *ebpf.MapSpec `ebpf:"target_pids"`
}

// denyVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type denyVariableSpecs struct {
}

// denyObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadDenyObjects or ebpf.CollectionSpec.LoadAndAssign.
type denyObjects struct {
	denyPrograms
	denyMaps
	denyVariables
}

func (o *denyObjects) Close() error {
	return _DenyClose(
		&o.denyPrograms,
		&o.denyMaps,
	)
}

// denyMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadDenyObjects or ebpf.CollectionSpec.LoadAndAssign.
type denyMaps struct {
	AllowedFilenames *ebpf.Map `ebpf:"allowed_filenames"`
	DeniedFilenames  *ebpf.Map `ebpf:"denied_filenames"`
	DeniedInodes     *ebpf.Map `ebpf:"denied_inodes"`
	Events           *ebpf.Map `ebpf:"events"`
	TargetPids       *ebpf.Map `ebpf:"target_pids"`
}

func (m *denyMaps) Close() error {
	return _DenyClose(
		m.AllowedFilenames,
		m.DeniedFilenames,
		m.DeniedInodes,
		m.Events,
		m.TargetPids,
	)
}

// denyVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadDenyObjects or ebpf.CollectionSpec.LoadAndAssign.
type denyVariables struct {
}

// denyPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadDenyObjects or ebpf.CollectionSpec.LoadAndAssign.
type denyPrograms struct {
	DenyFileOpen *ebpf.Program `ebpf:"deny_file_open"`
}

func (p *denyPrograms) Close() error {
	return _DenyClose(
		p.DenyFileOpen,
	)
}

func _DenyClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed deny_bpfel.o
var _DenyBytes []byte

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTrace = `-- name: CreateTrace :execlastid
INSERT INTO traces (trace_id, session_id, start_time)
VALUES (?, ?, ?)
`

type CreateTraceParams struct {
	TraceID   string     `json:"trace_id"`
	SessionID *string    `json:"session_id"`
	StartTime *time.Time `json:"start_time"`
}

func (q *Queries) CreateTrace(ctx context.Context, arg CreateTraceParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTrace, arg.TraceID, arg.SessionID, arg.StartTime)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteOldSpans = `-- name: DeleteOldSpans :execresult
DELETE FROM spans
WHERE trace_rowid IN (
    SELECT id FROM traces WHERE start_time < datetime('now', ?)
)
`

func (q *Queries) DeleteOldSpans(ctx context.Context, datetime interface{}) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteOldSpans, datetime)
}

const deleteOldToolCallLogs = `-- name: DeleteOldToolCallLogs :execresult

DELETE FROM tool_call_logs
WHERE timestamp < datetime('now', ?)
`

// =============================================================================
// Cleanup Operations
// =============================================================================
func (q *Queries) DeleteOldToolCallLogs(ctx context.Context, datetime interface{}) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteOldToolCallLogs, datetime)
}

const deleteOldTraces = `-- name: DeleteOldTraces :execresult
DELETE FROM traces
WHERE start_time < datetime('now', ?)
`

func (q *Queries) DeleteOldTraces(ctx context.Context, datetime interface{}) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteOldTraces, datetime)
}

const getRecentToolCallLogs = `-- name: GetRecentToolCallLogs :many
SELECT id, timestamp, trace_id, session_id, tool_name, tool_arguments,
    api_type, was_blocked, blocked_by_rule, model, layer
FROM tool_call_logs
WHERE timestamp > datetime('now', ?)
ORDER BY timestamp DESC
LIMIT ?
`

type GetRecentToolCallLogsParams struct {
	Datetime interface{} `json:"datetime"`
	Limit    int64       `json:"limit"`
}

func (q *Queries) GetRecentToolCallLogs(ctx context.Context, arg GetRecentToolCallLogsParams) ([]ToolCallLog, error) {
	rows, err := q.db.QueryContext(ctx, getRecentToolCallLogs, arg.Datetime, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolCallLog{}
	for rows.Next() {
		var i ToolCallLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.TraceID,
			&i.SessionID,
			&i.ToolName,
			&i.ToolArguments,
			&i.ApiType,
			&i.WasBlocked,
			&i.BlockedByRule,
			&i.Model,
			&i.Layer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpanCount = `-- name: GetSpanCount :one
SELECT COUNT(*) FROM spans
`

func (q *Queries) GetSpanCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSpanCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSpansByKind = `-- name: GetSpansByKind :many
SELECT span_kind, COUNT(*) as count
FROM spans
WHERE span_kind IS NOT NULL
GROUP BY span_kind
ORDER BY count DESC
`

type GetSpansByKindRow struct {
	SpanKind *string `json:"span_kind"`
	Count    int64   `json:"count"`
}

func (q *Queries) GetSpansByKind(ctx context.Context) ([]GetSpansByKindRow, error) {
	rows, err := q.db.QueryContext(ctx, getSpansByKind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSpansByKindRow{}
	for rows.Next() {
		var i GetSpansByKindRow
		if err := rows.Scan(&i.SpanKind, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenTotals = `-- name: GetTokenTotals :one
SELECT COALESCE(SUM(input_tokens), 0) as total_input,
       COALESCE(SUM(output_tokens), 0) as total_output
FROM spans
`

type GetTokenTotalsRow struct {
	TotalInput  interface{} `json:"total_input"`
	TotalOutput interface{} `json:"total_output"`
}

func (q *Queries) GetTokenTotals(ctx context.Context) (GetTokenTotalsRow, error) {
	row := q.db.QueryRowContext(ctx, getTokenTotals)
	var i GetTokenTotalsRow
	err := row.Scan(&i.TotalInput, &i.TotalOutput)
	return i, err
}

const getToolCallStats = `-- name: GetToolCallStats :one
SELECT COUNT(*) as total,
       COALESCE(SUM(CASE WHEN was_blocked THEN 1 ELSE 0 END), 0) as blocked
FROM tool_call_logs
`

type GetToolCallStatsRow struct {
	Total   int64       `json:"total"`
	Blocked interface{} `json:"blocked"`
}

func (q *Queries) GetToolCallStats(ctx context.Context) (GetToolCallStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getToolCallStats)
	var i GetToolCallStatsRow
	err := row.Scan(&i.Total, &i.Blocked)
	return i, err
}

const getTopBlockedTools = `-- name: GetTopBlockedTools :many
SELECT tool_name,
       COUNT(*) as total_calls,
       CAST(COALESCE(SUM(CASE WHEN was_blocked THEN 1 ELSE 0 END), 0) AS INTEGER) as blocked_calls
FROM tool_call_logs
GROUP BY tool_name
ORDER BY blocked_calls DESC
LIMIT 10
`

type GetTopBlockedToolsRow struct {
	ToolName     string `json:"tool_name"`
	TotalCalls   int64  `json:"total_calls"`
	BlockedCalls int64  `json:"blocked_calls"`
}

func (q *Queries) GetTopBlockedTools(ctx context.Context) ([]GetTopBlockedToolsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopBlockedTools)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopBlockedToolsRow{}
	for rows.Next() {
		var i GetTopBlockedToolsRow
		if err := rows.Scan(&i.ToolName, &i.TotalCalls, &i.BlockedCalls); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTraceByID = `-- name: GetTraceByID :one

SELECT id, trace_id, session_id, start_time, end_time, metadata, created_at
FROM traces
WHERE trace_id = ?
LIMIT 1
`

// =============================================================================
// Trace Operations
// =============================================================================
func (q *Queries) GetTraceByID(ctx context.Context, traceID string) (Trace, error) {
	row := q.db.QueryRowContext(ctx, getTraceByID, traceID)
	var i Trace
	err := row.Scan(
		&i.ID,
		&i.TraceID,
		&i.SessionID,
		&i.StartTime,
		&i.EndTime,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getTraceCount = `-- name: GetTraceCount :one
SELECT COUNT(*) FROM traces
`

func (q *Queries) GetTraceCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTraceCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTraceSpans = `-- name: GetTraceSpans :many
SELECT s.id, s.trace_rowid, s.span_id, s.parent_span_id, s.name, s.span_kind,
    s.start_time, s.end_time, s.attributes, s.events, s.input_tokens, s.output_tokens,
    s.status_code, s.status_message, s.created_at
FROM spans s
JOIN traces t ON s.trace_rowid = t.id
WHERE t.trace_id = ?
ORDER BY s.start_time
`

func (q *Queries) GetTraceSpans(ctx context.Context, traceID string) ([]Span, error) {
	rows, err := q.db.QueryContext(ctx, getTraceSpans, traceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Span{}
	for rows.Next() {
		var i Span
		if err := rows.Scan(
			&i.ID,
			&i.TraceRowid,
			&i.SpanID,
			&i.ParentSpanID,
			&i.Name,
			&i.SpanKind,
			&i.StartTime,
			&i.EndTime,
			&i.Attributes,
			&i.Events,
			&i.InputTokens,
			&i.OutputTokens,
			&i.StatusCode,
			&i.StatusMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSpan = `-- name: InsertSpan :execlastid

INSERT INTO spans (
    trace_rowid, span_id, parent_span_id, name, span_kind,
    start_time, end_time, attributes, events, input_tokens, output_tokens,
    status_code, status_message
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertSpanParams struct {
	TraceRowid    *int64     `json:"trace_rowid"`
	SpanID        string     `json:"span_id"`
	ParentSpanID  *string    `json:"parent_span_id"`
	Name          string     `json:"name"`
	SpanKind      *string    `json:"span_kind"`
	StartTime     *time.Time `json:"start_time"`
	EndTime       *time.Time `json:"end_time"`
	Attributes    []byte     `json:"attributes"`
	Events        []byte     `json:"events"`
	InputTokens   *int64     `json:"input_tokens"`
	OutputTokens  *int64     `json:"output_tokens"`
	StatusCode    *string    `json:"status_code"`
	StatusMessage *string    `json:"status_message"`
}

// =============================================================================
// Span Operations
// =============================================================================
func (q *Queries) InsertSpan(ctx context.Context, arg InsertSpanParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertSpan,
		arg.TraceRowid,
		arg.SpanID,
		arg.ParentSpanID,
		arg.Name,
		arg.SpanKind,
		arg.StartTime,
		arg.EndTime,
		arg.Attributes,
		arg.Events,
		arg.InputTokens,
		arg.OutputTokens,
		arg.StatusCode,
		arg.StatusMessage,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const listRecentTraces = `-- name: ListRecentTraces :many
SELECT id, trace_id, session_id, start_time, end_time, metadata, created_at
FROM traces
ORDER BY start_time DESC
LIMIT ?
`

func (q *Queries) ListRecentTraces(ctx context.Context, limit int64) ([]Trace, error) {
	rows, err := q.db.QueryContext(ctx, listRecentTraces, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Trace{}
	for rows.Next() {
		var i Trace
		if err := rows.Scan(
			&i.ID,
			&i.TraceID,
			&i.SessionID,
			&i.StartTime,
			&i.EndTime,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logToolCall = `-- name: LogToolCall :exec

INSERT INTO tool_call_logs (
    trace_id, session_id, tool_name, tool_arguments,
    api_type, was_blocked, blocked_by_rule, model, layer
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type LogToolCallParams struct {
	TraceID       string  `json:"trace_id"`
	SessionID     *string `json:"session_id"`
	ToolName      string  `json:"tool_name"`
	ToolArguments *string `json:"tool_arguments"`
	ApiType       *string `json:"api_type"`
	WasBlocked    *bool   `json:"was_blocked"`
	BlockedByRule *string `json:"blocked_by_rule"`
	Model         *string `json:"model"`
	Layer         *string `json:"layer"`
}

// =============================================================================
// Tool Call Logging
// =============================================================================
func (q *Queries) LogToolCall(ctx context.Context, arg LogToolCallParams) error {
	_, err := q.db.ExecContext(ctx, logToolCall,
		arg.TraceID,
		arg.SessionID,
		arg.ToolName,
		arg.ToolArguments,
		arg.ApiType,
		arg.WasBlocked,
		arg.BlockedByRule,
		arg.Model,
		arg.Layer,
	)
	return err
}

const updateTraceEndTime = `-- name: UpdateTraceEndTime :exec
UPDATE traces
SET end_time = ?
WHERE trace_id = ?
`

type UpdateTraceEndTimeParams struct {
	EndTime *time.Time `json:"end_time"`
	TraceID string     `json:"trace_id"`
}

func (q *Queries) UpdateTraceEndTime(ctx context.Context, arg UpdateTraceEndTimeParams) error {
	_, err := q.db.ExecContext(ctx, updateTraceEndTime, arg.EndTime, arg.TraceID)
	return err
}

const upsertTrace = `-- name: UpsertTrace :execlastid
INSERT INTO traces (trace_id, session_id, start_time)
VALUES (?, ?, ?)
ON CONFLICT(trace_id) DO UPDATE SET session_id = COALESCE(excluded.session_id, traces.session_id)
`

type UpsertTraceParams struct {
	TraceID   string     `json:"trace_id"`
	SessionID *string    `json:"session_id"`
	StartTime *time.Time `json:"start_time"`
}

func (q *Queries) UpsertTrace(ctx context.Context, arg UpsertTraceParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, upsertTrace, arg.TraceID, arg.SessionID, arg.StartTime)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
